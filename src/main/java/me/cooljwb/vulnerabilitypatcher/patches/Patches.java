package me.cooljwb.vulnerabilitypatcher.patches;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.Multimap;
import me.cooljwb.vulnerabilitypatcher.SMG;
import me.cooljwb.vulnerabilitypatcher.VulnerabilityPatcher;
import me.cooljwb.vulnerabilitypatcher.modifiers.NBTModifier;
import net.md_5.bungee.api.ChatColor;
import net.md_5.bungee.api.chat.*;
import org.apache.commons.lang.builder.ReflectionToStringBuilder;
import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.World;
import org.bukkit.attribute.Attribute;
import org.bukkit.attribute.AttributeModifier;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Entity;
import org.bukkit.entity.Player;
import org.bukkit.event.Event;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerMoveEvent;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.PlayerInventory;
import org.bukkit.scheduler.BukkitScheduler;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

/*
 * Copyright 2019 CoolJWB
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @author CoolJWB
 */

public class Patches extends NBTModifier implements Listener {

    // TODO: Add violation runnable that checks if it should send a violation each second for players that tries to use exploits.

    public static VulnerabilityPatcher main;
    public static String pluginName, pluginVersion;
    public static boolean notify, devmode;
    public List<String> listeners;

    private Death_Items death_items;
    private Disconnect_Items disconnect_items;
    private Crash_Items crash_items;
    private Rouge_Entity_Spigot rouge_entity;

    private Logger log = Logger.getLogger("Minecraft");

    private HashMap<String, Float> active_attributes = new HashMap<>();
    protected HashMap<Player, Float> player_speed = new HashMap<>();

    public static byte mode = 0;

    public Patches() {}
    public Patches(VulnerabilityPatcher main) {
        Patches.main = main;
        listeners = main.getConfig().getStringList("Patches");
        runnable();
    }

    public void initialize() {
        pluginName = main.getName();
        pluginVersion = main.getDescription().getVersion();
        notify = main.getConfig().getBoolean("Notify.Enabled");
        devmode = main.getConfig().getBoolean("DevMode");
        this.mode = mode(main.getConfig().getString("SecurityMode"));

        this.death_items = main.death_items;
        this.disconnect_items = main.disconnect_items;
        this.crash_items = main.crash_items;
    }
    public void runnable() {
        BukkitScheduler scheduler = Bukkit.getServer().getScheduler();
        scheduler.scheduleSyncRepeatingTask(main, new Runnable() {
            @Override
            public void run() {
                for(Player player : Bukkit.getOnlinePlayers()) {
                    if(player.getLocation().getY() <= -29999990) // Fixes invalid movement disconnection.
                        player.getLocation().setY(-29999990);
                    else if(player.getLocation().getY() >= 29999990) // Fixes invalid movement disconnection.
                        player.getLocation().setY(29999990);

                    for(ItemStack item : player.getInventory()) {
                        if(mode == 2) {
                            if(item != null && item.getItemMeta() != null) {
                                if(item.getItemMeta().getEnchants() != null && !item.getItemMeta().getEnchants().isEmpty()) {
                                    for (Map.Entry entry : item.getItemMeta().getEnchants().entrySet()) {
                                        if (((Integer) entry.getValue()) > 5)
                                            clearItemMeta(item);
                                    }
                                }

                                if(item.getItemMeta().getAttributeModifiers() != null && !item.getItemMeta().getAttributeModifiers().isEmpty()) {
                                    clearItemMeta(item);
                                }
                            }
                        } // Removes enchants above level 5 and attributes if the security mode is strict.
                    }
                    active_attributes.clear();
                }

                for(World world : Bukkit.getWorlds()) {
                    for(Entity entity : world.getEntities()) {
                        if(entity == null)
                            continue;

                        if(entity.getName().equalsIgnoreCase("Minecart with Spawner")) {
                            entity.remove(); // TODO: Make this configurable.
                        } // Remove Minecart Spawners.
                        if((entity.getVelocity().getX() > 10.0D || entity.getVelocity().getY() > 10.0D || entity.getVelocity().getZ() > 10.0D || entity.getVelocity().getX() < -6.0D || entity.getVelocity().getY() < -6.0D || entity.getVelocity().getZ() < -6.0D)) {
                            if(entity.getName().equals("Firework Rocket"))
                                entity.remove();
                            else {
                                if(entity.getVelocity().getX() > 10.0D)
                                    entity.getVelocity().setX(10);
                                else if(entity.getVelocity().getY() > 10.0D)
                                    entity.getVelocity().setY(10);
                                else if(entity.getVelocity().getZ() > 10.0D)
                                    entity.getVelocity().setZ(10);
                            }
                        } // Remove crazy fireworks.
                    }
                } // Remove Spawner Minecarts.
            }
        }, 20L, 0); // Made the delay 20 ticks cause it's easier on the server.
    }

    @EventHandler
    public void onPlayerMoveEvent(PlayerMoveEvent event) {
        double speedX = event.getTo().getX() - event.getFrom().getX();
        double speedY = event.getTo().getY() - event.getFrom().getY();
        double speedZ = event.getTo().getZ() - event.getFrom().getZ();
        double speed = speedX + speedY + speedZ;

        if(speed > 5 || speed < -5)
            event.setCancelled(true);
    }

    void msg(Player player, String msg) {
        player.sendMessage(msg);
    }
    protected void msg(CommandSender sender, String msg) {
        sender.sendMessage(msg);
    }

    public void notify(String msg) {
        if(notify) {
            for (Player player : Bukkit.getOnlinePlayers()) {
                if (player.hasPermission(main.getConfig().getString("Notify.Permission")))
                    player.sendMessage(msg);
            }
        }
    }
    private void notify(BaseComponent msg) {
        if(notify) {
            for (Player player : Bukkit.getOnlinePlayers()) {
                if (player.hasPermission(main.getConfig().getString("Notify.Permission")))
                    player.spigot().sendMessage(msg);
            }
        }
    }
    void notifyViolation(Player player, String violation_form, String violation_name, Location loc) {
        if(player != null) {
            TextComponent notification = new TextComponent(String.format(SMG.ITEM_NOTIFY.msg, player.getName(), violation_form, violation_name, loc.getBlockX(), loc.getBlockY(), loc.getBlockZ()));

            notification.setHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, new ComponentBuilder(ChatColor.DARK_GRAY + "[" + ChatColor.GOLD + "Teleport" + ChatColor.DARK_GRAY + "]").create()));
            notification.setClickEvent(new ClickEvent(ClickEvent.Action.RUN_COMMAND, "/tp " + loc.getBlockX() + " " + loc.getBlockY() + " " + loc.getBlockZ()));
            notification.setColor(ChatColor.RED);

            notify(notification);
        }

        else {
            TextComponent notification = new TextComponent(String.format(SMG.ITEM_NOTIFY.msg, "Unknown", violation_form, violation_name, loc.getBlockX(), loc.getBlockY(), loc.getBlockZ()));

            notification.setHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, new ComponentBuilder(ChatColor.DARK_GRAY + "[" + ChatColor.GOLD + "Teleport" + ChatColor.DARK_GRAY + "]").create()));
            notification.setClickEvent(new ClickEvent(ClickEvent.Action.RUN_COMMAND, "/tp " + loc.getBlockX() + " " + loc.getBlockY() + " " + loc.getBlockZ()));
            notification.setColor(ChatColor.RED);

            notify(notification);
        }
    }
    void notifyViolation(String violator, String violation_form, String violation_name, Location loc) {
        TextComponent notification = new TextComponent(String.format(SMG.ITEM_NOTIFY.msg, violator, violation_form, violation_name, loc.getBlockX(), loc.getBlockY(), loc.getBlockZ()));

        notification.setHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, new ComponentBuilder(ChatColor.DARK_GRAY + "[" + ChatColor.GOLD + "Teleport" + ChatColor.DARK_GRAY + "]").create()));
        notification.setClickEvent(new ClickEvent(ClickEvent.Action.RUN_COMMAND, "/tp " + loc.getBlockX() + " " + loc.getBlockY() + " " + loc.getBlockZ()));
        notification.setColor(ChatColor.RED);

        notify(notification);
    }

    public void log(Level level, String message) {
        log.log(level, String.format("[%s] %s", VulnerabilityPatcher.pluginName, message));
    }
    public void debug(Event event) {
        if (devmode)
            log(Level.INFO, String.format("Event in %s: %s", getClass().getName(), ReflectionToStringBuilder.toString(event)));
    }
    void fired_countermeasure(String reason) {
        if (devmode)
            log(Level.INFO, String.format("Fired countermeasure in %s reason: %s", getClass().getName(), reason));
    }
    private byte mode(String mode) {
        switch(mode) {
            case "EASY":
                return 0;
            case "MEDIUM":
                return 1;
            case "STRICT":
                return 2;
            default:
                return 0;
        }
    }

    void clearItemMeta(ItemStack item) {
        item.setItemMeta(null);
    }
    void clearItemMeta(ItemStack[] items) {
        for(ItemStack item : items) {
            if(item != null)
                item.setItemMeta(null);
        }
    }

    public boolean itemInVisibleSlot(PlayerInventory inv, ItemStack item) {
        ItemStack mainhand = inv.getItemInMainHand();
        ItemStack offhand = inv.getItemInOffHand();

    	if(item != null && inv != null && mainhand != null && offhand != null) {
    	    if(inv.getItemInMainHand().isSimilar(item) || inv.getItemInOffHand().isSimilar(item))
    	        return true;

    	    else {
    	        for(ItemStack items : inv.getArmorContents()) {
    	            if(items != null && items.isSimilar(item))
    	                return true;
                }
            }
    	}
    	return false;
    }
}
